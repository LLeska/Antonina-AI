# 🤖 Antonina-AI

**Решение контрольной работы ФAKT МФТИ осень 2025 с помощью машинного обучения**

> Семестровый проект по информатике  
> Факультет Аэрокосмических Технологий (ФАКТ), МФТИ  
> Осенний семестр 2025

---

##  Описание проекта

Этот проект представляет собой попытку решить задачу из первой контрольной работы по информатике с использованием методов машинного обучения, а именно — **нейроэволюции** (эволюции нейронных сетей с помощью генетического алгоритма).


# Условие задачи
## Описание задачи

Луноходу Антонине Келдышевне нужно принести ведро реголита, богатого гелием-3, на стартовую (посадочную) площадку.  
Задача сведена к классической постановке на поле 8×8.

### Символы на поле

-   `.` — пустая клетка
    
-   `O` — стартовая площадка
    
-   `a` — луноход Антонина Келдышевна
    
-   `%` — ведро реголита
    
-   `#` — камень
    
-   `@` — луноход находится на стартовой площадке (`a` + `O`)
    

### Начальные условия

-   В начале луноход находится в той же клетке, что и стартовая площадка (`@`).
    
-   Карта — матрица `char map[8][8]`.
    

### Правила движения

1.  За один ход луноход может переместиться на одну из четырёх соседних клеток (вверх/вниз/влево/вправо).
    
2.  Если впереди находится объект (`%` или `#`) и следующая за ним клетка пуста — луноход **толкает** этот объект (push).
    
3.  Если за луноходом в обратном направлении находится объект (`%` или `#`) и при попытке сделать шаг назад возможна «втащивание» (pull) — луноход **тащит** предмет за собой (pull). Луноход **жадно тянет**, если это возможно.
    
4.  Если одновременно возможны толкание и тяг — приоритет у **толкания** (не можно толкать и тянуть одновременно; в таком случае объект останется позади).
    
5.  Нельзя затолкать камень `#` на стартовую площадку `O`.
    
6.  Цель — доставить ведро `%` на стартовую площадку `O`. Как только `%` оказывается на `O` — тест считается пройденным.

7.  Луноход не может толкать и тащить одновременно. В таком случае, он бросит предмет позади и будет только толкать.

   Иллюстрация с пояснением.  Слева направо: луноход толкает ведро, луноход тянет камушек, луноход не может затолкать камень на площадку и не может сдвинуть его вбок, луноход занят толканием ведра и оставляет камень позади. 
   <img width="2058" height="613" alt="download" src="https://github.com/user-attachments/assets/b52cbfb2-28ac-4ca7-b3d1-e6e1d39ea468" />


### Интерфейс, который нужно реализовать

    
-   `char Move(char map[][8], int ant_x, int ant_y, int home_x, int home_y, int sample_x, int sample_y);`  
    Вызывается каждый шаг; должна вернуть одно из:
    
    -   `u` — вверх (x-1)
        
    -   `d` — вниз (x+1)
        
    -   `l` — влево (y-1)
        
    -   `r` — вправо (y+1)
  
    Пример массива map:
<img width="660" height="653" alt="download" src="https://github.com/user-attachments/assets/6a392962-72fb-439f-874f-4ef27bc5879d" />



Аргументы:

-   `map` — текущее состояние поля (8×8)
    
-   `ant_x, ant_y` — координаты лунохода
    
-   `home_x, home_y` — координаты стартовой площадки
    
-   `sample_x, sample_y` — координаты ведра
    


### Параметры (задаваемые в коде)

-   `TIME_TO_SLEEP` — ms задержки для отрисовки
    
-   `PRINT_STEPS` — отрисовывать анимацию или нет
    
-   `STEPS_LIMIT` — максимальное число шагов на один тест (на сервере ≤ 256)
    
-   `N_TESTS` — число повторений для статистики
    

### Оценивание

-   Если ведро доставлено — начисляются очки; чем быстрее — тем больше.
    
-   Если не успел — 0 очков за этот тест.
    
-   Общий результат усредняется по тестам и суммируется по категориям.

### Тесты:

Луноход будет решать различные задачи с все возрастающей сложностью.
<img width="1116" height="845" alt="download" src="https://github.com/user-attachments/assets/a7e0b7be-46d9-48ae-ae7a-a3aae09cc6bd" />
#  Решение: Нейроэволюция
Архитектура нейросети
```text
64 (поле 8×8) → 32 → 16 → 8 → 4 (направления)
```

### Генетический алгоритм
- Популяция: 1000 сетей

- Элита: 10% лучших

- Селекция: Турнирная (k=2-5)

- Мутация: Адаптивная (σ=0.01-1.5)

- Иммигранты: 5% случайных

Цикл эволюции
```text
1. Тестирование → 2. Сортировка → 3. Селекция →  4. Кроссовер → 5. Мутация → 6. Адаптация → (повтор)
```

## Блок схема наград нейросети
```text
       Блок схема наград за прохождение теста
┌─────────────────────────────────────────────────────────────┐
│                      НАЧАЛО ТЕСТА                           │
│           test_score = BASE_SCORE (50)                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│         Получить result из GoTestImproved                   │
│  + min_rover_to_bucket, min_bucket_to_pad, bucket_picked    │
│           result ∈ { >0, -1, -2 }                          │
└──────────────────────────┬──────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        ▼                  ▼                  ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  result > 0     │ │  result == -1   │ │  result == -2   │
│    (УСПЕХ)      │ │   (неуспех)     │ │    (АВАРИЯ)     │
└────────┬────────┘ └────────┬────────┘ └────────┬────────┘
         │                   │                   │
         ▼                   │                   ▼
┌─────────────────┐          │         ┌──────────────────┐
│ += SUCCESS_BASE │          │         │ test_score =     │
│     (1000)      │          │         │ max(0, score -   │
└────────┬────────┘          │         │ TERMINATE_       │
         │                   │         │ PENALTY(100))    │
         ▼                   │         └────────┬─────────┘
┌─────────────────┐          │                  │
│ steps_saved =   │          │                  ▼
│ LIMIT - result  │          │         ┌──────────────────┐
└────────┬────────┘          │         │ ВОЗВРАТ          │
         │                   │         │ test_score       │
         ▼                   │         └──────────────────┘
┌─────────────────┐          │
│ += steps_saved  │          │
│ * STEP_BONUS    │          │
│      (15)       │          │
└────────┬────────┘          │
         │                   │
         ▼                   ▼
┌─────────────────┐ ┌─────────────────────────────────────┐
│ steps ≤ LIMIT/2?│ │         ФАЗА 1: ЛУНОХОД → ВЕДРО     │
└────────┬────────┘ └──────────────┬──────────────────────┘
         │ Да                      │
         ▼                         ▼
┌─────────────────┐      ┌──────────────────────┐
│ += EFFICIENCY   │      │ rover_progress =     │
│ BONUS (200)     │      │ initial - min        │
└────────┬────────┘      └──────────┬───────────┘
         │                          │
         │                          ▼
         │               ┌──────────────────────┐
         │               │ progress > 0?        │
         │               └──────┬───────────────┘
         │                      │ Да
         │                      ▼
         │               ┌──────────────────────┐
         │               │ += progress *        │
         │               │ DISTANCE_REDUCTION_  │
         │               │ BONUS (25)           │
         │               └──────────┬───────────┘
         │                          │
         ▼                          ▼
┌─────────────────────────────────────────────┐
│      ВОЗВРАТ test_score                     │
└─────────────────────────────────────────────┘
                           │
                           ▼
              ┌────────────────────────┐
              │ bucket_picked == true? │
              └────────┬───────────────┘
                       │ Да
                       ▼
              ┌────────────────────────┐
              │ += PICKED_BUCKET_      │
              │    BONUS (400)         │
              └────────┬───────────────┘
                       │
                       ▼
     ┌─────────────────────────────────────────┐
     │   ФАЗА 2: ВЕДРО → ПЛОЩАДКА              │
     └──────────────────┬──────────────────────┘
                        │
                        ▼
              ┌────────────────────────┐
              │ bucket_progress =      │
              │ initial_bucket -       │
              │ min_bucket_to_pad      │
              └────────┬───────────────┘
                       │
                       ▼
              ┌────────────────────────┐
              │ bucket_progress > 0?   │
              └────────┬───────────────┘
                       │ Да
                       ▼
              ┌────────────────────────┐
              │ += bucket_progress *   │
              │ BUCKET_TO_PAD_BONUS    │
              │        (20)            │
              └────────┬───────────────┘
                       │
                       ▼
              ┌────────────────────────┐
              │ min_bucket_to_pad ≤ 2? │
              └────────┬───────────────┘
                       │ Да
                       ▼
              ┌────────────────────────┐
              │ += ALMOST_THERE_       │
              │    BONUS (150)         │
              └────────┬───────────────┘
                       │
                       ▼
              ┌────────────────────────┐
              │  ВОЗВРАТ test_score    │
              └────────────────────────┘
                       │
                       │ Нет (ведро не взято)
                       ▼
              ┌────────────────────────┐
              │ rover_progress ≤ 0?    │
              └────────┬───────────────┘
                       │ Да
                       ▼
              ┌────────────────────────┐
              │ score = max(BASE_SCORE,│
              │ score - NO_PROGRESS_   │
              │ PENALTY(5))            │
              └────────┬───────────────┘
                       │
                       ▼
              ┌────────────────────────┐
              │  ВОЗВРАТ test_score    │
              └────────────────────────┘

```

## Диапазон итоговых очков

| СЦЕНАРИЙ                    	| ПРИМЕРНЫЕ ОЧКИ 	|
|-----------------------------	|----------------	|
| Полный провал (result=-2)   	| 0 - 50         	|
| Нет прогресса               	| 45 - 100       	|
| Приблизился к ведру (3 кл.) 	| 125 - 200      	|
| Приблизился к ведру (6 кл.) 	| 200 - 300      	|
| Взял ведро, не двигал       	| 500 - 650      	|
| Взял + приблизил на 3 кл.   	| 650 - 850      	|
| Взял + почти доставил       	| 800 - 1100     	|
| УСПЕХ медленно (35+ шагов)  	| 1050 - 1200    	|
| УСПЕХ средне (20-35 шагов)  	| 1200 - 1500    	|
| УСПЕХ быстро (<20 шагов)    	| 1500 - 1850    	|

#  Структура
```text
Antonina-AI/
├── Layer.h/cpp           # Слой нейросети
├── Perceptron.h/cpp      # Полносвязная сеть
├── NeuroEvolution.h/cpp  # Генетический алгоритм
├── AntoninaAPI.h/cpp     # Игровая среда
├── main.cpp              # Точка входа
├── Test0.csv             # 4032 теста
└── models/               # Сохранённые модели
```

# Компиляция 
### Linux/macOS
```bash
g++ -std=c++17 main.cpp Layer.cpp Perceptron.cpp NeuroEvolution.cpp AntoninaAPI.cpp -o antonina_ai
    
./antonina_ai
```
### Windows
```text
Открыть Antonina-AI.sln → F5
```

#  Настройки
main.cpp:

```cpp
double learning_rate = 0.01; // Коэфициент обучения перцептрона
int length = 5; // Колличество слоев нейросети
int* sizes = new int[length] { 64, 32, 16, 8, 4 }; // Размеры каждого слоя (в данном случае первые и последние должны быть неизменны, для решения нашей задачи)
int parents_size = 50;      // Родителей
int population = 1000;      // Размер популяции
...
int start = 4905; // С какого поколения начать обучение 
```

AntoninaAPI.h:
```cpp
const int TIME_TO_SLEEP = 0; //Задержка анимации при демонстрации
const int STEPS_LIMIT = 40; // Лимит шагов
```
