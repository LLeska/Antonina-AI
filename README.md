# Условие задачи
## Описание задачи

Луноходу Антонине Келдышевне нужно принести ведро реголита, богатого гелием-3, на стартовую (посадочную) площадку.  
Задача сведена к классической постановке на поле 8×8.

### Символы на поле

-   `.` — пустая клетка
    
-   `O` — стартовая площадка
    
-   `a` — луноход Антонина Келдышевна
    
-   `%` — ведро реголита
    
-   `#` — камень
    
-   `@` — луноход находится на стартовой площадке (`a` + `O`)
    

### Начальные условия

-   В начале луноход находится в той же клетке, что и стартовая площадка (`@`).
    
-   Карта — матрица `char map[8][8]`.
    

### Правила движения

1.  За один ход луноход может переместиться на одну из четырёх соседних клеток (вверх/вниз/влево/вправо).
    
2.  Если впереди находится объект (`%` или `#`) и следующая за ним клетка пуста — луноход **толкает** этот объект (push).
    
3.  Если за луноходом в обратном направлении находится объект (`%` или `#`) и при попытке сделать шаг назад возможна «втащивание» (pull) — луноход **тащит** предмет за собой (pull). Луноход **жадно тянет**, если это возможно.
    
4.  Если одновременно возможны толкание и тяг — приоритет у **толкания** (не можно толкать и тянуть одновременно; в таком случае объект останется позади).
    
5.  Нельзя затолкать камень `#` на стартовую площадку `O`.
    
6.  Цель — доставить ведро `%` на стартовую площадку `O`. Как только `%` оказывается на `O` — тест считается пройденным.

7.  Луноход не может толкать и тащить одновременно. В таком случае, он бросит предмет позади и будет только толкать.

   Иллюстрация с пояснением.  Слева направо: луноход толкает ведро, луноход тянет камушек, луноход не может затолкать камень на площадку и не может сдвинуть его вбок, луноход занят толканием ведра и оставляет камень позади. 
   <img width="2058" height="613" alt="download" src="https://github.com/user-attachments/assets/b52cbfb2-28ac-4ca7-b3d1-e6e1d39ea468" />


### Интерфейс, который нужно реализовать

    
-   `char Move(char map[][8], int ant_x, int ant_y, int home_x, int home_y, int sample_x, int sample_y);`  
    Вызывается каждый шаг; должна вернуть одно из:
    
    -   `u` — вверх (x-1)
        
    -   `d` — вниз (x+1)
        
    -   `l` — влево (y-1)
        
    -   `r` — вправо (y+1)
    Пример массива map:
<img width="660" height="653" alt="download" src="https://github.com/user-attachments/assets/6a392962-72fb-439f-874f-4ef27bc5879d" />



Аргументы:

-   `map` — текущее состояние поля (8×8)
    
-   `ant_x, ant_y` — координаты лунохода
    
-   `home_x, home_y` — координаты стартовой площадки
    
-   `sample_x, sample_y` — координаты ведра
    


### Параметры (задаваемые в коде)

-   `TIME_TO_SLEEP` — ms задержки для отрисовки
    
-   `PRINT_STEPS` — отрисовывать анимацию или нет
    
-   `STEPS_LIMIT` — максимальное число шагов на один тест (на сервере ≤ 256)
    
-   `N_TESTS` — число повторений для статистики
    

### Оценивание

-   Если ведро доставлено — начисляются очки; чем быстрее — тем больше.
    
-   Если не успел — 0 очков за этот тест.
    
-   Общий результат усредняется по тестам и суммируется по категориям.

###Тесты:

Луноход будет решать различные задачи с все возрастающей сложностью.
<img width="1116" height="845" alt="download" src="https://github.com/user-attachments/assets/a7e0b7be-46d9-48ae-ae7a-a3aae09cc6bd" />

# Блок схема наград нейросети
```text
            
           ┌─────────────────────────────┐
           │         НАЧАЛО ТЕСТА        │
           └──────────────┬──────────────┘
                          │
                          ▼
           ┌─────────────────────────────┐
           │ Получить result из GoTest   │
           │ result ∈ { >0, -1, -2 }    │
           └──────────────┬──────────────┘
                          │
           ┌──────────────┼──────────────┐
           ▼              ▼              ▼
   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐
   │  result > 0   │ │  result == -1 │ │  result == -2 │
   │   (успех)     │ │  (неуспех)    │ │   (авария)    │
   └──────┬────────┘ └──────┬────────┘ └──────┬────────┘
          │                 │                 │
          ▼                 ▼                 ▼
   ┌───────────────┐ ┌───────────────────┐ ┌───────────────┐
   │ remaining =   │ │ distance_reduction │ │ reward =      │
   │ LIMIT - steps │ │ = initial - min    │ │ TERMINATE     │
   └──────┬────────┘ └──────┬────────────┘ └──────┬────────┘
          │                 │                 │
          ▼                 ▼                 ▼
   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐
   │ reward =      │ │ reduction > 0 │ │ clamp reward  │
   │ SUCCESS_BASE  │ │ ?             │ │               │
   │ + remaining*  │ │               │ │               │
   │ STEP_BONUS    │ │               │ │               │
   └──────┬────────┘ └──────┬────────┘ └──────┬────────┘
          │                 │                 │
          ▼                 │                 ▼
   ┌───────────────┐        │          ┌───────────────┐
   │ clamp reward  │        │          │ ВОЗВРАТ reward│
   └──────┬────────┘        │          └───────────────┘
          │                 │
          ▼                 ▼
   ┌───────────────┐  ┌───────────────┐
   │ ВОЗВРАТ reward│  │ reward =      │
   │               │  │ reduction *   │
   │               │  │ CLOSE_BONUS   │
   └───────────────┘  └──────┬────────┘
                             ▼
                      ┌───────────────┐
                      │ clamp reward  │
                      └──────┬────────┘
                             ▼
                      ┌───────────────┐
                      │ ВОЗВРАТ reward│
                      └───────────────┘
```
